package aman.lyricify;

import android.app.AlertDialog;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.Bundle;
import android.text.InputType;
import android.view.ContextThemeWrapper;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;
import com.bumptech.glide.Glide;
import com.google.android.material.appbar.MaterialToolbar;
import com.google.android.material.button.MaterialButton;
import com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton;
import com.google.android.material.textfield.TextInputEditText;
import com.google.android.material.textfield.TextInputLayout;
import aman.taglib.TagLib;
import org.json.JSONArray;
import org.json.JSONObject;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class TagEditorActivityREFERENCE extends AppCompatActivity {

    private ImageView artworkImageView;
    private TextView fileNameText;
    private TextInputEditText titleEditText, artistEditText, albumEditText;
    private TextInputEditText genreEditText, yearEditText, trackNumberEditText;
    private TextInputEditText composerEditText, commentEditText;
    private MaterialToolbar toolbar;
    private MaterialButton changeArtworkButton, resetArtworkButton, fetchFromApiButton, clearFieldsButton;
    private ExtendedFloatingActionButton saveButton, addFieldButton;
    private LinearLayout tagFieldsContainer;
    private FrameLayout loadingOverlay;
    private TextView loadingText;

    private String filePath;
    private TagLib tagLib;
    private Bitmap selectedArtwork;
    private Bitmap originalArtwork;
    private boolean artworkChanged = false;
    private HashMap<String, String> originalMetadata;
    
    // Song data from intent
    private String intentTitle;
    private String intentArtist;
    private String intentAlbum;
    private String intentArtworkUrl;
    private String intentSongId;
    
    // Custom fields
    private List<CustomField> customFields = new ArrayList<>();

    private ActivityResultLauncher<Intent> imagePickerLauncher;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_tag_editor);

        tagLib = new TagLib();
        initializeViews();
        setupToolbar();
        setupImagePickerLauncher();
        extractIntentData();
        loadCurrentTags();
        setupListeners();
    }

    private void initializeViews() {
        toolbar = findViewById(R.id.toolbar);
        artworkImageView = findViewById(R.id.artworkImageView);
        fileNameText = findViewById(R.id.fileNameText);
        titleEditText = findViewById(R.id.titleEditText);
        artistEditText = findViewById(R.id.artistEditText);
        albumEditText = findViewById(R.id.albumEditText);
        genreEditText = findViewById(R.id.genreEditText);
        yearEditText = findViewById(R.id.yearEditText);
        trackNumberEditText = findViewById(R.id.trackNumberEditText);
        composerEditText = findViewById(R.id.composerEditText);
        commentEditText = findViewById(R.id.commentEditText);

        changeArtworkButton = findViewById(R.id.changeArtworkButton);
        resetArtworkButton = findViewById(R.id.resetArtworkButton);
        fetchFromApiButton = findViewById(R.id.fetchFromApiButton);
        clearFieldsButton = findViewById(R.id.clearFieldsButton);
        saveButton = findViewById(R.id.saveButton);
        addFieldButton = findViewById(R.id.addFieldButton);
        
        tagFieldsContainer = findViewById(R.id.tagFieldsContainer);

        loadingOverlay = findViewById(R.id.loadingOverlay);
        loadingText = findViewById(R.id.loadingText);
    }

    private void setupToolbar() {
        setSupportActionBar(toolbar);
        if (getSupportActionBar() != null) {
            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
            getSupportActionBar().setDisplayShowHomeEnabled(true);
        }
        
        toolbar.setNavigationOnClickListener(v -> onBackPressed());
        
        toolbar.setOnMenuItemClickListener(item -> {
            if (item.getItemId() == R.id.action_save) {
                saveTags();
                return true;
            }
            return false;
        });
    }

    private void setupImagePickerLauncher() {
        imagePickerLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if (result.getResultCode() == RESULT_OK && result.getData() != null) {
                    Uri imageUri = result.getData().getData();
                    if (imageUri != null) {
                        loadArtworkFromUri(imageUri);
                    }
                }
            }
        );
    }

    private void extractIntentData() {
        filePath = getIntent().getStringExtra("FILE_PATH");
        intentTitle = getIntent().getStringExtra("SONG_TITLE");
        intentArtist = getIntent().getStringExtra("SONG_ARTIST");
        intentAlbum = getIntent().getStringExtra("SONG_ALBUM");
        intentArtworkUrl = getIntent().getStringExtra("ARTWORK_URL");
        intentSongId = getIntent().getStringExtra("SONG_ID");
        
        if (filePath != null) {
            File file = new File(filePath);
            fileNameText.setText(file.getName());
        }
    }

    private void loadCurrentTags() {
        if (filePath == null || filePath.isEmpty()) {
            Toast.makeText(this, "No file path provided", Toast.LENGTH_SHORT).show();
            return;
        }

        showLoading("Loading tags...");

        new Thread(() -> {
            try {
                originalMetadata = tagLib.getMetadata(filePath);
                
                if (originalMetadata != null && !originalMetadata.isEmpty()) {
                    runOnUiThread(() -> {
                        titleEditText.setText(originalMetadata.get("TITLE"));
                        artistEditText.setText(originalMetadata.get("ARTIST"));
                        albumEditText.setText(originalMetadata.get("ALBUM"));
                        genreEditText.setText(originalMetadata.get("GENRE"));
                        yearEditText.setText(originalMetadata.get("DATE"));
                        trackNumberEditText.setText(originalMetadata.get("TRACKNUMBER"));
                        composerEditText.setText(originalMetadata.get("COMPOSER"));
                        commentEditText.setText(originalMetadata.get("COMMENT"));
                    });
                }

                TagLib.Artwork[] artworks = tagLib.getArtwork(filePath);
                if (artworks != null && artworks.length > 0) {
                    byte[] artworkData = artworks[0].data;
                    Bitmap bitmap = BitmapFactory.decodeByteArray(artworkData, 0, artworkData.length);
                    if (bitmap != null) {
                        originalArtwork = bitmap;
                        runOnUiThread(() -> artworkImageView.setImageBitmap(bitmap));
                    }
                } else if (intentArtworkUrl != null && !intentArtworkUrl.isEmpty()) {
                    runOnUiThread(() -> loadArtworkFromUrl(intentArtworkUrl));
                }

                runOnUiThread(() -> hideLoading());

            } catch (Exception e) {
                runOnUiThread(() -> {
                    hideLoading();
                    Toast.makeText(this, "Error reading tags: " + e.getMessage(), 
                        Toast.LENGTH_SHORT).show();
                });
            }
        }).start();
    }

    private void setupListeners() {
        saveButton.setOnClickListener(v -> saveTags());
        changeArtworkButton.setOnClickListener(v -> selectArtwork());
        resetArtworkButton.setOnClickListener(v -> resetArtwork());
        fetchFromApiButton.setOnClickListener(v -> fetchTagsFromApi());
        clearFieldsButton.setOnClickListener(v -> showClearConfirmation());
        addFieldButton.setOnClickListener(v -> showAddCustomFieldDialog());
    }

    private void selectArtwork() {
        Intent intent = new Intent(Intent.ACTION_PICK);
        intent.setType("image/*");
        imagePickerLauncher.launch(intent);
    }

    private void loadArtworkFromUri(Uri uri) {
        try {
            InputStream inputStream = getContentResolver().openInputStream(uri);
            selectedArtwork = BitmapFactory.decodeStream(inputStream);
            artworkImageView.setImageBitmap(selectedArtwork);
            artworkChanged = true;
            resetArtworkButton.setVisibility(View.VISIBLE);
            inputStream.close();
            Toast.makeText(this, "Artwork updated", Toast.LENGTH_SHORT).show();
        } catch (Exception e) {
            Toast.makeText(this, "Error loading image: " + e.getMessage(), 
                Toast.LENGTH_SHORT).show();
        }
    }
    
    private void resetArtwork() {
        if (originalArtwork != null) {
            artworkImageView.setImageBitmap(originalArtwork);
            selectedArtwork = null;
            artworkChanged = false;
            resetArtworkButton.setVisibility(View.GONE);
            Toast.makeText(this, "Artwork reset", Toast.LENGTH_SHORT).show();
        } else {
            artworkImageView.setImageResource(R.drawable.ic_music_note);
            selectedArtwork = null;
            artworkChanged = false;
            resetArtworkButton.setVisibility(View.GONE);
            Toast.makeText(this, "Artwork removed", Toast.LENGTH_SHORT).show();
        }
    }
    
    private void loadArtworkFromUrl(String artworkUrl) {
        String url = artworkUrl
            .replace("{w}", "600")
            .replace("{h}", "600")
            .replace("{f}", "jpg");
            
        Glide.with(this)
            .asBitmap()
            .load(url)
            .into(new com.bumptech.glide.request.target.CustomTarget<Bitmap>() {
                @Override
                public void onResourceReady(Bitmap resource, 
                    com.bumptech.glide.request.transition.Transition<? super Bitmap> transition) {
                    artworkImageView.setImageBitmap(resource);
                }

                @Override
                public void onLoadCleared(android.graphics.drawable.Drawable placeholder) {}
            });
    }

    private void fetchTagsFromApi() {
        if (intentSongId != null && !intentSongId.isEmpty()) {
            showLoading("Fetching from API...");
            
            ApiClient.searchSongs(intentTitle + " " + intentArtist, new ApiClient.SearchCallback() {
                @Override
                public void onSuccess(ArrayList<Song> songs) {
                    hideLoading();
                    if (songs.isEmpty()) {
                        runOnUiThread(() -> 
                            Toast.makeText(TagEditorActivity.this, "No results found", 
                                Toast.LENGTH_SHORT).show()
                        );
                    } else {
                        Song matchedSong = null;
                        for (Song song : songs) {
                            if (song.getId().equals(intentSongId)) {
                                matchedSong = song;
                                break;
                            }
                        }
                        if (matchedSong == null) matchedSong = songs.get(0);
                        
                        Song finalSong = matchedSong;
                        runOnUiThread(() -> populateFieldsFromSong(finalSong));
                    }
                }

                @Override
                public void onFailure(String error) {
                    hideLoading();
                    runOnUiThread(() -> 
                        Toast.makeText(TagEditorActivity.this, "Error: " + error, 
                            Toast.LENGTH_SHORT).show()
                    );
                }
            });
            return;
        }
        
        String title = titleEditText.getText().toString().trim();
        String artist = artistEditText.getText().toString().trim();

        if (title.isEmpty() && artist.isEmpty()) {
            Toast.makeText(this, "Enter title or artist to search", Toast.LENGTH_SHORT).show();
            return;
        }

        showLoading("Fetching from API...");

        String query = title.isEmpty() ? artist : (artist.isEmpty() ? title : title + " " + artist);

        ApiClient.searchSongs(query, new ApiClient.SearchCallback() {
            @Override
            public void onSuccess(ArrayList<Song> songs) {
                hideLoading();
                if (songs.isEmpty()) {
                    runOnUiThread(() -> 
                        Toast.makeText(TagEditorActivity.this, "No results found", 
                            Toast.LENGTH_SHORT).show()
                    );
                } else {
                    runOnUiThread(() -> showSongSelectionDialog(songs));
                }
            }

            @Override
            public void onFailure(String error) {
                hideLoading();
                runOnUiThread(() -> 
                    Toast.makeText(TagEditorActivity.this, "Error: " + error, 
                        Toast.LENGTH_SHORT).show()
                );
            }
        });
    }

    private void showSongSelectionDialog(ArrayList<Song> songs) {
        String[] songTitles = new String[songs.size()];
        for (int i = 0; i < songs.size(); i++) {
            songTitles[i] = songs.get(i).getSongName() + " - " + songs.get(i).getArtistName();
        }

        new AlertDialog.Builder(this)
            .setTitle("Select Song")
            .setItems(songTitles, (dialog, which) -> {
                Song selectedSong = songs.get(which);
                populateFieldsFromSong(selectedSong);
            })
            .setNegativeButton("Cancel", null)
            .show();
    }

    private void populateFieldsFromSong(Song song) {
        titleEditText.setText(song.getSongName());
        artistEditText.setText(song.getArtistName());
        albumEditText.setText(song.getAlbumName());
        
        // Extract year from release date
        String releaseDate = song.getReleaseDate();
        if (releaseDate != null && releaseDate.length() >= 4) {
            yearEditText.setText(releaseDate.substring(0, 4));
        }
        
        // Add content rating if available
        if (song.getContentRating() != null && !song.getContentRating().isEmpty()) {
            addOrUpdateCustomField("CONTENTRATING", song.getContentRating());
        }
        
        // Parse additional metadata from full track data if available
        try {
            JSONObject trackData = song.getFullTrackData();
            if (trackData != null) {
                // Disc Number
                if (trackData.has("discNumber")) {
                    int discNumber = trackData.getInt("discNumber");
                    addOrUpdateCustomField("DISCNUMBER", String.valueOf(discNumber));
                }
                
                // Track Number (if not already set)
                if (trackData.has("trackNumber")) {
                    int trackNum = trackData.getInt("trackNumber");
                    trackNumberEditText.setText(String.valueOf(trackNum));
                }
                
                // ISRC
                if (trackData.has("isrc")) {
                    String isrc = trackData.getString("isrc");
                    if (!isrc.isEmpty()) {
                        addOrUpdateCustomField("ISRC", isrc);
                    }
                }
                
                // Songwriters from metadata
                if (trackData.has("metadata")) {
                    JSONObject metadata = trackData.getJSONObject("metadata");
                    if (metadata.has("songwriters")) {
                        JSONArray songwriters = metadata.getJSONArray("songwriters");
                        StringBuilder songwritersStr = new StringBuilder();
                        for (int i = 0; i < songwriters.length(); i++) {
                            if (i > 0) songwritersStr.append(", ");
                            songwritersStr.append(songwriters.getString(i));
                        }
                        composerEditText.setText(songwritersStr.toString());
                    }
                }
                
                // Genre names
                if (trackData.has("genreNames")) {
                    JSONArray genreNames = trackData.getJSONArray("genreNames");
                    if (genreNames.length() > 0) {
                        genreEditText.setText(genreNames.getString(0));
                    }
                }
            }
        } catch (Exception e) {
            // Silently fail if metadata parsing fails
        }

        // Load artwork
        String artworkUrl = song.getArtwork()
            .replace("{w}", "600")
            .replace("{h}", "600")
            .replace("{f}", "jpg");

        showLoading("Loading artwork...");

        Glide.with(this)
            .asBitmap()
            .load(artworkUrl)
            .into(new com.bumptech.glide.request.target.CustomTarget<Bitmap>() {
                @Override
                public void onResourceReady(Bitmap resource, 
                    com.bumptech.glide.request.transition.Transition<? super Bitmap> transition) {
                    selectedArtwork = resource;
                    artworkImageView.setImageBitmap(resource);
                    artworkChanged = true;
                    resetArtworkButton.setVisibility(View.VISIBLE);
                    hideLoading();
                    Toast.makeText(TagEditorActivity.this, "Tags fetched successfully", 
                        Toast.LENGTH_SHORT).show();
                }

                @Override
                public void onLoadCleared(android.graphics.drawable.Drawable placeholder) {
                    hideLoading();
                }
            });
    }
    
    private void showAddCustomFieldDialog() {
        View dialogView = LayoutInflater.from(this).inflate(R.layout.dialog_add_custom_field, null);
        EditText tagEditText = dialogView.findViewById(R.id.tagNameEditText);
        EditText valueEditText = dialogView.findViewById(R.id.tagValueEditText);
        
        new AlertDialog.Builder(this)
            .setTitle("Add Custom Field")
            .setView(dialogView)
            .setPositiveButton("Add", (dialog, which) -> {
                String tag = tagEditText.getText().toString().trim().toUpperCase();
                String value = valueEditText.getText().toString().trim();
                
                if (tag.isEmpty() || value.isEmpty()) {
                    Toast.makeText(this, "Both fields are required", Toast.LENGTH_SHORT).show();
                    return;
                }
                
                addCustomField(tag, value);
            })
            .setNegativeButton("Cancel", null)
            .show();
    }
    
    private void addOrUpdateCustomField(String tag, String value) {
        // Check if field already exists
        for (CustomField field : customFields) {
            if (field.tag.equals(tag)) {
                field.value = value;
                field.editText.setText(value);
                return;
            }
        }
        addCustomField(tag, value);
    }
    
    private void addCustomField(String tag, String value) {
        CustomField customField = new CustomField();
        customField.tag = tag;
        customField.value = value;
   