package aman.lyricify.Views;

import android.animation.Animator;
import android.animation.ValueAnimator;
import android.content.Context;
import android.graphics.*;
import android.util.AttributeSet;
import androidx.appcompat.widget.AppCompatTextView;
import android.view.animation.LinearInterpolator;

public class GlowTextView extends AppCompatTextView {
    private Paint basePaint;
    private Paint glowPaint;
    private LinearGradient gradient;
    private float progress = 0f;
    private int viewWidth;
    private ValueAnimator animator;
    private boolean isAnimating = false;

    public GlowTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    private void init() {
        setLayerType(LAYER_TYPE_SOFTWARE, null);

        basePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        basePaint.setColor(Color.GRAY);
        basePaint.setStyle(Paint.Style.FILL);
        basePaint.setTextAlign(Paint.Align.LEFT);

        glowPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        glowPaint.setStyle(Paint.Style.FILL);
        glowPaint.setTextAlign(Paint.Align.LEFT);
        glowPaint.setMaskFilter(new BlurMaskFilter(20, BlurMaskFilter.Blur.NORMAL));
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        viewWidth = w;
    }

                @Override
    protected void onDraw(Canvas canvas) {
        String text = getText().toString();
        
        // 1. Setup Paints & Measurements
        float textSize = getTextSize();
        basePaint.setTextSize(textSize);
        glowPaint.setTextSize(textSize);
        basePaint.setTypeface(getTypeface());
        glowPaint.setTypeface(getTypeface());

        Paint.FontMetrics fm = basePaint.getFontMetrics();
        float textHeight = fm.descent - fm.ascent;
        float y = (getHeight() + textHeight) / 2 - fm.descent;
        
        // Calculate exact text position
        float textWidth = basePaint.measureText(text);
        float textX = (getWidth() - textWidth) / 2;

        // 2. Draw the inactive gray base first
        basePaint.setColor(Color.GRAY);
        // Clear any shader on the base paint to ensure it's solid gray
        basePaint.setShader(null); 
        canvas.drawText(text, textX, y, basePaint);

        // 3. Calculate the "Wipe" position
        // We want a gradient of roughly 120px width for the soft edge
        float edgeWidth = 120f; 
        
        // Start Position: The fade hasn't touched the text yet
        // We subtract edgeWidth so the 'Transparent' end of the gradient is at textX
        float startCutoff = textX;
        
        // End Position: The solid white has fully crossed the text
        // We add edgeWidth so the 'White' start of the gradient clears the end of text
        float endCutoff = textX + textWidth + edgeWidth;
        
        // Current position based on animation progress
        float totalTravel = endCutoff - startCutoff;
        float currentX = startCutoff + (progress * totalTravel);

        // 4. Create the Shader (The "Magic" part)
        // Gradient runs from [White] -> [Transparent]
        // TileMode.CLAMP means:
        //   - Everything BEFORE (currentX - edgeWidth) stays WHITE (Solid fill)
        //   - Everything AFTER (currentX) stays TRANSPARENT (Empty)
        LinearGradient fillGradient = new LinearGradient(
                currentX - edgeWidth, 0,  // Start of fade (Solid White before this)
                currentX, 0,              // End of fade (Transparent after this)
                new int[]{Color.WHITE, Color.TRANSPARENT},
                null,                     // evenly distributed
                Shader.TileMode.CLAMP     // <--- This fixes the artifact
        );

        // 5. Draw the Sharp White Text (The Fill)
        Paint fillPaint = new Paint(basePaint);
        fillPaint.setColor(Color.WHITE);
        fillPaint.setShader(fillGradient);
        canvas.drawText(text, textX, y, fillPaint);

        // 6. Draw the Glow (The Bloom effect on top)
        // We use the same gradient logic but with the blur paint
        glowPaint.setShader(fillGradient);
        canvas.drawText(text, textX, y, glowPaint);
    }




    private void startSweep() {
        if (viewWidth <= 0) return;
        if (isAnimating) return;
        isAnimating = true;

        animator = ValueAnimator.ofFloat(0f, 1f);
        animator.setDuration(10000); // sweep duration
        animator.setInterpolator(new LinearInterpolator());
        animator.addUpdateListener(
                a -> {
                    progress = (float) a.getAnimatedValue();
                    invalidate();
                });

        animator.addListener(
                new Animator.AnimatorListener() {
                    @Override
                    public void onAnimationStart(Animator animation) {}

                    @Override
                    public void onAnimationEnd(Animator animation) {
                        // pause briefly when fully white
                        postDelayed(() -> resetAndRestart(), 1000); // 1s pause
                    }

                    @Override
                    public void onAnimationCancel(Animator animation) {}

                    @Override
                    public void onAnimationRepeat(Animator animation) {}
                });

        animator.start();
    }

    private void resetAndRestart() {
        // Fade back to gray
        ValueAnimator fadeBack = ValueAnimator.ofFloat(1f, 0f);
        fadeBack.setDuration(1000);
        fadeBack.setInterpolator(new LinearInterpolator());
        fadeBack.addUpdateListener(
                a -> {
                    float fadeProgress = (float) a.getAnimatedValue();
                    // blend gray & white
                    basePaint.setColor(blendColor(Color.GRAY, Color.WHITE, fadeProgress));
                    invalidate();
                });
        fadeBack.addListener(
                new Animator.AnimatorListener() {
                    @Override
                    public void onAnimationStart(Animator animation) {}

                    @Override
                    public void onAnimationEnd(Animator animation) {
                        progress = 0f;
                        isAnimating = false;
                        startSweep(); // restart cycle
                    }

                    @Override
                    public void onAnimationCancel(Animator animation) {}

                    @Override
                    public void onAnimationRepeat(Animator animation) {}
                });
        fadeBack.start();
    }

    private int blendColor(int startColor, int endColor, float ratio) {
        int alpha =
                (int)
                        (Color.alpha(startColor)
                                + (Color.alpha(endColor) - Color.alpha(startColor)) * ratio);
        int red =
                (int)
                        (Color.red(startColor)
                                + (Color.red(endColor) - Color.red(startColor)) * ratio);
        int green =
                (int)
                        (Color.green(startColor)
                                + (Color.green(endColor) - Color.green(startColor)) * ratio);
        int blue =
                (int)
                        (Color.blue(startColor)
                                + (Color.blue(endColor) - Color.blue(startColor)) * ratio);
        return Color.argb(alpha, red, green, blue);
    }

    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        post(this::startSweep);
    }

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (animator != null) animator.cancel();
    }
}
