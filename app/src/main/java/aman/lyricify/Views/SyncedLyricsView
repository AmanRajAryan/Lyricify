package aman.lyricify;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Shader;
import android.graphics.Typeface;
import android.util.AttributeSet;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.widget.OverScroller;

import androidx.annotation.Nullable;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class SyncedLyricsView extends View {

    // ==================================================================================
    // 1. DATA MODELS & INTERFACES
    // ==================================================================================

    public interface SeekListener {
        void onSeek(long timeMs);
    }

    public static class LyricLine {
        public long startTime;
        public long endTime; // New: Supports explicit end time for multiline overlap
        public List<LyricWord> words = new ArrayList<>();

        public LyricLine(long startTime) {
            this.startTime = startTime;
        }
    }

    public static class LyricWord {
        public long time;
        public String text;

        public LyricWord(long time, String text) {
            this.time = time;
            this.text = text;
        }
    }

    public static class LrcParser {
        public static List<LyricLine> parse(InputStream inputStream) {
            List<LyricLine> lines = new ArrayList<>();
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    LyricLine parsedLine = parseLine(line);
                    if (parsedLine != null) lines.add(parsedLine);
                }
                Collections.sort(lines, (a, b) -> Long.compare(a.startTime, b.startTime));

                // Fallback: If no explicit endTime was found, verify validity
                for (int i = 0; i < lines.size(); i++) {
                    LyricLine curr = lines.get(i);
                    if (curr.endTime == 0) {
                        // If we didn't find an end tag, default to a safe duration (e.g. 3s or next
                        // line start)
                        // However, with multiline support, explicit tags are preferred.
                        if (i < lines.size() - 1) {
                            // Only use next line start if it's actually after current start
                            long nextStart = lines.get(i + 1).startTime;
                            if (nextStart > curr.startTime) {
                                curr.endTime = nextStart;
                            } else {
                                curr.endTime = curr.startTime + 3000;
                            }
                        } else {
                            curr.endTime = curr.startTime + 3000;
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            return lines;
        }

        private static LyricLine parseLine(String line) {
            Pattern linePattern = Pattern.compile("\\[(\\d{2}):(\\d{2})\\.(\\d{2,3})\\](.*)");
            Matcher lineMatcher = linePattern.matcher(line);
            if (lineMatcher.find()) {
                int min = Integer.parseInt(lineMatcher.group(1));
                int sec = Integer.parseInt(lineMatcher.group(2));
                String msStr = lineMatcher.group(3);
                int ms = Integer.parseInt(msStr) * (msStr.length() == 2 ? 10 : 1);
                long startTime = (min * 60L + sec) * 1000L + ms;
                String content = lineMatcher.group(4);

                // Remove optional speaker labels like "v2:"
                if (content != null) content = content.replaceFirst("^[^<]*:", "");

                LyricLine lyricLine = new LyricLine(startTime);

                // Regex matches <time>text
                // The group 4 (text) matches everything until the next '<'
                Pattern wordPattern = Pattern.compile("<(\\d{2}):(\\d{2})\\.(\\d{2,3})>([^<]*)");
                Matcher wordMatcher = wordPattern.matcher(content);

                while (wordMatcher.find()) {
                    int wMin = Integer.parseInt(wordMatcher.group(1));
                    int wSec = Integer.parseInt(wordMatcher.group(2));
                    String wMsStr = wordMatcher.group(3);
                    int wMs = Integer.parseInt(wMsStr) * (wMsStr.length() == 2 ? 10 : 1);
                    long wordTime = (wMin * 60L + wSec) * 1000L + wMs;

                    String text = wordMatcher.group(4);
                    lyricLine.words.add(new LyricWord(wordTime, text));
                }

                // Logic to extract End Time from the last tag
                if (!lyricLine.words.isEmpty()) {
                    LyricWord lastEntry = lyricLine.words.get(lyricLine.words.size() - 1);
                    // If the last "word" has empty text, it is the closing timestamp <00:35.940>
                    if (lastEntry.text == null || lastEntry.text.trim().isEmpty()) {
                        lyricLine.endTime = lastEntry.time;
                        // Remove this marker from the words list so it doesn't render
                        lyricLine.words.remove(lyricLine.words.size() - 1);
                    } else {
                        // If the line didn't end with an empty tag, endTime is 0 (handled in
                        // fallback)
                        lyricLine.endTime = 0;
                    }
                    // Ensure we still have words to show
                    if (!lyricLine.words.isEmpty()) return lyricLine;
                }
            }
            return null;
        }
    }

    // ==================================================================================
    // 2. VIEW IMPLEMENTATION
    // ==================================================================================

    private List<LyricLine> lyrics = new ArrayList<>();
    private List<WrappedLine> wrappedLines = new ArrayList<>();
    private Map<LyricLine, Float> lineCenterYMap = new HashMap<>();

    private long currentTime = 0;

    // Paints
    private Paint paintActive, paintDefault, paintPast;
    private Paint paintFill, paintBloom;
    private Paint paintFps;

    // Optimization
    private LinearGradient masterGradient;
    private Matrix shaderMatrix = new Matrix();

    // Metrics
    private float textHeight;
    private float padding = 48;
    private float spacingBetweenWrappedLines;
    private float spacingBetweenLyrics;

    // Scrolling logic
    private float targetScrollY = 0;
    private float currentScrollY = 0;

    // Physics & Touch
    private boolean isUserScrolling = false;
    private boolean isFlinging = false;
    private float lastTouchY = 0;
    private VelocityTracker velocityTracker;
    private OverScroller scroller;
    private int minFlingVelocity;
    private int maxFlingVelocity;
    private GestureDetector gestureDetector;

    // Listeners
    private SeekListener seekListener;

    // Auto-Scroll Resume
    private Runnable resumeAutoScrollRunnable;
    private static final long AUTO_SCROLL_RESUME_DELAY = 2500;
    private static final long SCROLL_ANTICIPATION_MS = 600;

    // FPS
    private long lastFpsTime = 0;
    private int frameCount = 0;
    private int currentFps = 0;

    // Layout
    private float totalContentHeight = 0;

    // Fonts
    private int currentFontIndex = 0;
    private static final Typeface[] FONTS = {
        Typeface.DEFAULT,
        Typeface.SERIF,
        Typeface.SANS_SERIF,
        Typeface.MONOSPACE,
        Typeface.create("cursive", Typeface.NORMAL),
        Typeface.create("casual", Typeface.NORMAL)
    };
    private static final String[] FONT_NAMES = {
        "Default", "Serif", "Sans Serif", "Monospace", "Cursive", "Casual"
    };

    public SyncedLyricsView(Context context) {
        this(context, null);
    }

    public SyncedLyricsView(Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SyncedLyricsView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init(context);
    }

    private void init(Context context) {
        float density = getResources().getDisplayMetrics().scaledDensity;
        float textSize = 32 * density;

        spacingBetweenWrappedLines = 10 * density;
        spacingBetweenLyrics = 60 * density;

        // Initial Paint Setup
        paintActive = new Paint(Paint.ANTI_ALIAS_FLAG);
        paintActive.setTextSize(textSize);
        paintActive.setColor(Color.WHITE);
        paintActive.setFakeBoldText(true);

        paintDefault = new Paint(Paint.ANTI_ALIAS_FLAG);
        paintDefault.setTextSize(textSize);
        paintDefault.setColor(Color.argb(102, 255, 255, 255));
        paintDefault.setFakeBoldText(true);

        paintPast = new Paint(Paint.ANTI_ALIAS_FLAG);
        paintPast.setTextSize(textSize);
        paintPast.setColor(Color.argb(80, 255, 255, 255));
        paintPast.setFakeBoldText(true);

        paintFill = new Paint(Paint.ANTI_ALIAS_FLAG);
        paintFill.setTextSize(textSize);
        paintFill.setFakeBoldText(true);

        paintBloom = new Paint(Paint.ANTI_ALIAS_FLAG);
        paintBloom.setTextSize(textSize);
        paintBloom.setFakeBoldText(true);
        paintBloom.setShadowLayer(25, 0, 0, Color.WHITE);

        paintFps = new Paint(Paint.ANTI_ALIAS_FLAG);
        paintFps.setColor(Color.GREEN);
        paintFps.setTextSize(18 * density);
        paintFps.setFakeBoldText(true);
        paintFps.setTextAlign(Paint.Align.RIGHT);

        updateTextHeight();

        // Physics
        scroller = new OverScroller(context);
        ViewConfiguration vc = ViewConfiguration.get(context);
        minFlingVelocity = vc.getScaledMinimumFlingVelocity();
        maxFlingVelocity = vc.getScaledMaximumFlingVelocity();

        resumeAutoScrollRunnable =
                () -> {
                    isUserScrolling = false;
                    isFlinging = false;
                    postInvalidateOnAnimation();
                };

        // Click Detection
        gestureDetector =
                new GestureDetector(
                        context,
                        new GestureDetector.SimpleOnGestureListener() {
                            @Override
                            public boolean onSingleTapUp(MotionEvent e) {
                                return handleTap(e.getY());
                            }
                        });
    }

    private void updateTextHeight() {
        Paint.FontMetrics fm = paintActive.getFontMetrics();
        textHeight = fm.descent - fm.ascent;
    }

    // --- PUBLIC API ---

    public void setSeekListener(SeekListener listener) {
        this.seekListener = listener;
    }

    public String cycleFont() {
        currentFontIndex = (currentFontIndex + 1) % FONTS.length;
        Typeface newTypeface = FONTS[currentFontIndex];

        paintActive.setTypeface(Typeface.create(newTypeface, Typeface.BOLD));
        paintDefault.setTypeface(Typeface.create(newTypeface, Typeface.BOLD));
        paintPast.setTypeface(Typeface.create(newTypeface, Typeface.BOLD));
        paintFill.setTypeface(Typeface.create(newTypeface, Typeface.BOLD));
        paintBloom.setTypeface(Typeface.create(newTypeface, Typeface.BOLD));

        updateTextHeight();
        requestLayout();
        invalidate();

        return FONT_NAMES[currentFontIndex];
    }

    public void setLyrics(String lyricsText) {
        if (lyricsText == null || lyricsText.isEmpty()) return;
        ByteArrayInputStream inputStream =
                new ByteArrayInputStream(lyricsText.getBytes(StandardCharsets.UTF_8));
        List<LyricLine> parsedLines = LrcParser.parse(inputStream);
        setLyrics(parsedLines);
    }

    public void setLyrics(List<LyricLine> lyrics) {
        this.lyrics = lyrics;
        requestLayout();
        invalidate();
    }

    public void updateTime(long timeMs) {
        this.currentTime = timeMs;
        postInvalidateOnAnimation();
    }

    // --- INTERNAL LOGIC ---

    private boolean handleTap(float touchY) {
        if (seekListener == null || wrappedLines.isEmpty()) return false;

        float clickedContentY = touchY + currentScrollY;

        Paint.FontMetrics fm = paintActive.getFontMetrics();
        float ascent = fm.ascent;
        float descent = fm.descent;
        float verticalPadding = 30f;

        for (WrappedLine wl : wrappedLines) {
            float top = wl.y + ascent - verticalPadding;
            float bottom = wl.y + descent + verticalPadding;

            if (clickedContentY >= top && clickedContentY <= bottom) {
                seekListener.onSeek(wl.parentLine.startTime);
                playSoundEffect(android.view.SoundEffectConstants.CLICK);
                return true;
            }
        }
        return false;
    }

    private boolean updateScrollLogic() {
        // 1. Handle Physics Fling
        if (isFlinging) {
            if (scroller.computeScrollOffset()) {
                currentScrollY = scroller.getCurrY();
                return true;
            } else {
                isFlinging = false;
                postDelayed(resumeAutoScrollRunnable, AUTO_SCROLL_RESUME_DELAY);
            }
        }

        // 2. User Interaction Check
        if (isUserScrolling || isFlinging) {
            return false;
        }

        // 3. Auto-Scroll Logic
        if (!lyrics.isEmpty()) {
            // Find the "Latest" started line to control scrolling
            int scrollTargetIndex = -1;
            for (int i = 0; i < lyrics.size(); i++) {
                if (currentTime >= lyrics.get(i).startTime) {
                    scrollTargetIndex = i;
                } else {
                    break;
                }
            }

            int effectiveIndex = Math.max(0, scrollTargetIndex);
            LyricLine currentLine = lyrics.get(effectiveIndex);

            Float centerY = lineCenterYMap.get(currentLine);
            if (centerY == null) centerY = 0f;

            float desiredY = centerY - getHeight() / 2f;

            // Anticipate next line scroll
            if (effectiveIndex + 1 < lyrics.size()) {
                LyricLine nextLine = lyrics.get(effectiveIndex + 1);
                long timeUntilNext = nextLine.startTime - currentTime;

                if (timeUntilNext < SCROLL_ANTICIPATION_MS && timeUntilNext > 0) {
                    float ratio = 1f - ((float) timeUntilNext / SCROLL_ANTICIPATION_MS);
                    Float nextCenterY = lineCenterYMap.get(nextLine);
                    if (nextCenterY != null) {
                        float nextTargetY = nextCenterY - getHeight() / 2f;
                        desiredY = desiredY + (nextTargetY - desiredY) * ratio;
                    }
                }
            }

            float minScroll = -getHeight() / 2f;
            targetScrollY = Math.max(minScroll, desiredY);
        }

        float diff = targetScrollY - currentScrollY;
        if (Math.abs(diff) > 0.5f) {
            currentScrollY += diff * 0.08f;
            return true;
        } else {
            currentScrollY = targetScrollY;
            return false;
        }
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int width = MeasureSpec.getSize(widthMeasureSpec);
        if (width > 0 && !lyrics.isEmpty()) wrapLines(width);
        int contentHeight =
                (int) (totalContentHeight + getResources().getDisplayMetrics().heightPixels / 2);
        setMeasuredDimension(width, contentHeight);
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        if (w > 0) {
            masterGradient =
                    new LinearGradient(
                            0,
                            0,
                            100,
                            0,
                            new int[] {Color.WHITE, Color.TRANSPARENT},
                            null,
                            Shader.TileMode.CLAMP);
        }
    }

    private void wrapLines(int viewWidth) {
        wrappedLines.clear();
        lineCenterYMap.clear();

        float maxWidth = viewWidth - (padding * 2);
        if (maxWidth <= 0) return;

        float currentY = 0;
        LyricLine previousParent = null;

        for (LyricLine line : lyrics) {
            List<LyricWord> currentLineWords = new ArrayList<>();
            float currentLineWidth = 0;
            long segmentStartTime = line.startTime;

            float parentStartY = -1;
            float parentLastLineY = -1;

            int i = 0;
            while (i < line.words.size()) {
                // 1. Build a "Cluster"
                List<LyricWord> cluster = new ArrayList<>();
                float clusterWidth = 0;

                LyricWord firstPiece = line.words.get(i);
                cluster.add(firstPiece);
                clusterWidth += paintActive.measureText(firstPiece.text);
                i++;

                while (i < line.words.size()) {
                    LyricWord lastAdded = cluster.get(cluster.size() - 1);
                    if (lastAdded.text.endsWith(" ") || lastAdded.text.endsWith("\u3000")) {
                        break;
                    }

                    LyricWord nextPiece = line.words.get(i);
                    cluster.add(nextPiece);
                    clusterWidth += paintActive.measureText(nextPiece.text);
                    i++;
                }

                // 2. Check if cluster fits
                if (currentLineWidth + clusterWidth > maxWidth && !currentLineWords.isEmpty()) {
                    // Wrap
                    float spacing =
                            (previousParent == line)
                                    ? spacingBetweenWrappedLines
                                    : spacingBetweenLyrics;
                    if (previousParent == null) spacing = 0;
                    currentY += spacing;

                    if (parentStartY == -1) parentStartY = currentY;

                    WrappedLine wl = new WrappedLine(line, new ArrayList<>(currentLineWords));
                    wl.y = currentY;
                    wl.startTime = segmentStartTime;
                    wrappedLines.add(wl);

                    parentLastLineY = currentY;
                    currentY += textHeight;
                    previousParent = line;

                    segmentStartTime = cluster.get(0).time;
                    currentLineWords.clear();
                    currentLineWidth = 0;
                }

                // 3. Add cluster
                currentLineWords.addAll(cluster);
                currentLineWidth += clusterWidth;
            }

            // Flush remaining words
            if (!currentLineWords.isEmpty()) {
                float spacing =
                        (previousParent == line)
                                ? spacingBetweenWrappedLines
                                : spacingBetweenLyrics;
                if (previousParent == null) spacing = 0;
                currentY += spacing;

                if (parentStartY == -1) parentStartY = currentY;

                WrappedLine wl = new WrappedLine(line, new ArrayList<>(currentLineWords));
                wl.y = currentY;
                wl.startTime = segmentStartTime;
                wrappedLines.add(wl);

                parentLastLineY = currentY;
                currentY += textHeight;
                previousParent = line;
            }

            if (parentStartY != -1 && parentLastLineY != -1) {
                float centerY = (parentStartY + parentLastLineY) / 2f;
                lineCenterYMap.put(line, centerY);
            }
        }
        totalContentHeight = currentY;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        long now = System.currentTimeMillis();
        frameCount++;
        if (now - lastFpsTime >= 1000) {
            currentFps = frameCount;
            frameCount = 0;
            lastFpsTime = now;
        }

        if (lyrics.isEmpty() || wrappedLines.isEmpty()) return;

        boolean animatingScroll = updateScrollLogic();

        canvas.save();
        canvas.translate(0, -currentScrollY);

        boolean animatingGlow = false;

        for (WrappedLine wl : wrappedLines) {
            float y = wl.y;
            float x = padding;

            if (y > currentScrollY + getHeight() || y < currentScrollY - textHeight) {
                continue;
            }

            // MULTILINE LOGIC UPDATES:
            // 1. Is the line "Active"? (Current time is within start and end)
            boolean isActiveLine =
                    (currentTime >= wl.parentLine.startTime
                            && currentTime <= wl.parentLine.endTime);
            // 2. Is the line "Past"? (Current time is completely after end)
            boolean isPastLine = (currentTime > wl.parentLine.endTime);

            for (LyricWord word : wl.words) {
                float wordWidth = paintActive.measureText(word.text);

                if (isActiveLine && currentTime >= word.time) {
                    // This word is currently singing or already sung within the ACTIVE line
                    animatingGlow = true;
                    drawActiveWord(canvas, word, wl, x, y, wordWidth);
                } else if (isPastLine) {
                    canvas.drawText(word.text, x, y, paintPast);
                } else {
                    // Future words (in active line or future lines)
                    canvas.drawText(word.text, x, y, paintDefault);
                }
                x += wordWidth;
            }
        }
        canvas.restore();

        canvas.drawText(String.valueOf(currentFps), getWidth() - 50, 100, paintFps);

        if (animatingScroll || animatingGlow) {
            postInvalidateOnAnimation();
        }
    }

    private void drawActiveWord(
            Canvas canvas, LyricWord word, WrappedLine wl, float x, float y, float wordWidth) {
        long nextWordTime = Long.MAX_VALUE;
        int wordIndex = wl.parentLine.words.indexOf(word);

        if (wordIndex < wl.parentLine.words.size() - 1) {
            // Next word in the same line
            nextWordTime = wl.parentLine.words.get(wordIndex + 1).time;
        } else {
            // Last word: Use line END TIME
            // This is critical for multiline support to prevent jumping to the next (overlapping)
            // line's start time
            nextWordTime = wl.parentLine.endTime;
        }

        long duration = nextWordTime - word.time;
        if (duration <= 0) duration = 1; // Prevent div/0

        long elapsed = currentTime - word.time;
        float progress = Math.min(1.0f, (float) elapsed / duration);

        // Draw Base
        canvas.drawText(word.text, x, y, paintDefault);

        if (masterGradient != null) {
            float edgeWidth = 120f;
            float currentX = x + (wordWidth + edgeWidth) * progress;

            shaderMatrix.reset();
            shaderMatrix.setScale(edgeWidth / 100f, 1f);
            shaderMatrix.postTranslate(currentX - edgeWidth, 0);
            masterGradient.setLocalMatrix(shaderMatrix);

            paintFill.setShader(masterGradient);
            canvas.drawText(word.text, x, y, paintFill);

            if (progress < 1.0f) {
                float bloomAlpha = 1.0f;
                if (progress >= 0.8f) bloomAlpha = (1.0f - progress) / 0.2f;

                paintBloom.setShader(masterGradient);
                paintBloom.setAlpha((int) (255 * bloomAlpha));
                canvas.drawText(word.text, x, y, paintBloom);
            }
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // 1. Process Gestures (Clicks)
        boolean isTap = gestureDetector.onTouchEvent(event);

        // 2. Process Physics (Fling/Scroll)
        if (velocityTracker == null) {
            velocityTracker = VelocityTracker.obtain();
        }
        velocityTracker.addMovement(event);

        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                isUserScrolling = true;
                isFlinging = false;
                scroller.forceFinished(true);
                removeCallbacks(resumeAutoScrollRunnable);
                lastTouchY = event.getY();
                return true;

            case MotionEvent.ACTION_MOVE:
                float deltaY = event.getY() - lastTouchY;
                currentScrollY -= deltaY;
                float maxScroll = Math.max(0, totalContentHeight + (getHeight() / 2f));
                currentScrollY = Math.max(0, Math.min(currentScrollY, maxScroll));
                lastTouchY = event.getY();
                postInvalidateOnAnimation();
                return true;

            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:
                if (isTap) {
                    isUserScrolling = false;
                    removeCallbacks(resumeAutoScrollRunnable);
                    postInvalidateOnAnimation();
                } else {
                    velocityTracker.computeCurrentVelocity(1000, maxFlingVelocity);
                    float velocityY = velocityTracker.getYVelocity();

                    if (Math.abs(velocityY) > minFlingVelocity) {
                        isFlinging = true;
                        scroller.fling(
                                0,
                                (int) currentScrollY,
                                0,
                                (int) -velocityY,
                                0,
                                0,
                                (int) (-getHeight() / 2f),
                                (int) (totalContentHeight + getHeight() / 2f));
                        postInvalidateOnAnimation();
                    } else {
                        postDelayed(resumeAutoScrollRunnable, AUTO_SCROLL_RESUME_DELAY);
                    }
                }

                if (velocityTracker != null) {
                    velocityTracker.recycle();
                    velocityTracker = null;
                }
                return true;
        }
        return super.onTouchEvent(event);
    }

    private static class WrappedLine {
        LyricLine parentLine;
        List<LyricWord> words;
        float y;
        long startTime;

        WrappedLine(LyricLine parentLine, List<LyricWord> words) {
            this.parentLine = parentLine;
            this.words = words;
        }
    }
}
